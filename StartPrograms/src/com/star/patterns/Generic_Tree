
public class GenericTree {

    private static class Node {
        int data;
        ArrayList<Node> childern = new ArrayList<>();
        public Node(int data)
        {
            this.data = data;
        }
        Node()
        {

        }
    }

    private static class  Pair{
        public Pair(Node node, int level) {
            this.node = node;
            this.level = level;
        }
        Node node;
        int level;
    }

    private static Node getRoot(int [] arr) {
        Node root = null;
        Stack<Node> stack = new Stack<>();

        for (int i = 0;i < arr.length;i++) {
            if (arr[i] == -1) {
                stack.pop();
            }
            else
            {
                Node n = new Node();
                n.data = arr[i];
                if (!stack.isEmpty()) {
                    stack.peek().childern.add(n);
                } else {
                    root = n;
                }
                stack.push(n);
            }
        }
        return root;
    }

    public static void display(Node node) {
        String str = node.data + " --> ";
        for (Node child : node.childern) {
            str += child.data + ", ";
        }
        str = str + ".";
        System.out.println(str);
        for (Node child : node.childern) {
            display(child);
        }
    }

    public static int size(Node node) {
        int size = 0;
        for (Node child : node.childern) {
            int cs = size(child);
            size = size + cs;
        }
        size = size + 1;
        return size;
    }

    public static int maximum(Node node) {
        int max = Integer.MIN_VALUE;
        for (Node child : node.childern) {
            int cmax = maximum(child);
            max = Math.max(cmax, max);
        }
        max = Math.max(node.data, max);
        return max;
    }

    public static int height(Node node) {
        int height = -1; //in terms of edges;
        for (Node child : node.childern) {
            int ch = height(child); //return height of child;
            height = Math.max(ch, height);
        }
        height = height + 1;
        return height; //return height
    }

    public static void traversals(Node node) {
        System.out.println("Node Pre : " + node.data); //Pre Area;
        for (Node child : node.childern) {
            System.out.println("Edge Pre : " + node.data + " -> " + child.data); //Pre Edge Area;
            traversals(child);
            System.out.println("Edge Post : " + node.data + " -> " + child.data); //Post Edge Area;
        }
        System.out.println("Node Post : " + node.data);
    }

    public static void levelOrderTraversal(Node node) {
        //R-P-A (Remove, Print, Add)
        Queue<Node> queue = new ArrayDeque<>();
        queue.add(node);
        while (!queue.isEmpty()) {
            node = queue.remove();
            System.out.print(node.data + " -> ");
            queue.addAll(node.childern);
        }
        System.out.println(".");
    }

    public static void levelOrderLineWiseTraversal(Node node) {
        Queue<Node> queue = new ArrayDeque<>();
        queue.add(node);
        Queue<Node> cQueue = new ArrayDeque<>();
        System.out.println("Traversal Begins...");
        while (!queue.isEmpty()) {
            node = queue.remove();
            System.out.print(node.data + " ");
            cQueue.addAll(node.childern);

            if (queue.isEmpty()) {
                queue = cQueue;
                cQueue = new ArrayDeque<>();
                System.out.println();
            }
        }
        System.out.println("Traversal Ends Here !!");
    }

    public static void levelOrderLineWiseTraversal2(Node node){
        Queue<Node> queue = new ArrayDeque<>();
        queue.add(node);
        queue.add(new Node(-1));
        while (!queue.isEmpty()){
            node = queue.remove();
            if(node.data!=-1)
            {
                System.out.print(node.data + " ");
                queue.addAll(node.childern);
            }
            else {
                if(!queue.isEmpty()) {
                    queue.add(new Node(-1));
                    System.out.println();
                }
            }
        }
        System.out.println();
    }

    public static void levelOrderLineWiseTraversal3(Node node){
        Queue<Node> queue = new ArrayDeque<>();
        queue.add(node);
        while (!queue.isEmpty()){
            int child_in_current_level = queue.size();
            for (int i=0;i<child_in_current_level;i++){
                node = queue.remove();
                System.out.print(node.data+" ");

                for (Node child: node.childern){
                    queue.add(child);
                }
            }
            System.out.println();
        }
    }

    public static void levlOrderLineWiseTraversal4(Node node){
        Queue<Pair> queue =  new ArrayDeque<>();
        queue.add(new Pair(node,1));

        int level=1;
        while (!queue.isEmpty()){
            Pair p = queue.remove();
            if(p.level > level){
                level = p.level;
                System.out.println();
            }

            System.out.print(p.node.data+" ");
            for (Node child: p.node.childern){ // adding all childern of node.
                Pair cp = new Pair(child,p.level+1);
                queue.add(cp);
            }
        }

        System.out.println();
    }

    public static void zigZagTraversal(Node node){
        Stack<Node> stack = new Stack<>();
        stack.push(node);
        Stack<Node> cStack = new Stack<>();
        int level=1;
        System.out.println("ZigZag Traversal Begins here : ");
        while (!stack.isEmpty()){
            node = stack.pop();
            System.out.print(node.data+ " ");

            if(level % 2 == 1){
                for(int i=0;i<node.childern.size();i++){
                    Node child  = node.childern.get(i);
                    cStack.push(child);
                }
            }
            else {
                for(int i=node.childern.size()-1;i>=0;i--){
                    Node child  = node.childern.get(i);
                    cStack.push(child);
                }

            }

            if(stack.isEmpty()){
                stack = cStack;
                cStack = new Stack<>();
                level++;
                System.out.println();
            }
        }
        System.out.println("ZigZag Traversal Ends Here !!");
    }

    public static boolean areTreesSimilar(Node node1,Node node2){

        if(node1.childern.size()!=node2.childern.size()){
            return false;
        }

        for (int i=0;i<node1.childern.size();i++){
            Node c1 = node1.childern.get(i);
            Node c2 = node2.childern.get(i);

            if(!areTreesSimilar(c1, c2)){
                return false;
            }
        }
        return true;
    }

    public static boolean areTreeMirror(Node node1, Node node2){
        if(node1.childern.size() != node2.childern.size()){
            return false;
        }
        for (int i=0;i<node1.childern.size();i++){
            int j = node1.childern.size()-1-i;

            Node c1 = node1.childern.get(i);
            Node c2 = node2.childern.get(j);

            if(!areTreeMirror(c1, c2)){
                return false;
            }
        }
        return true;
    }

    static Node predecessor;
    static Node successor;
    static int state;
    public static void findPredecessorAndSuccessor(Node node, int element){
        if(state==0) {
            if (node.data == element) {
                state = 1;
            } else {
                predecessor = node;
            }

        }
        else if(state==1){
            successor = node;
            state=2;
        }

        for (Node child: node.childern){
            findPredecessorAndSuccessor(child,element);
        }
    }

    public static void removeLeaves(Node node){

        for(int i=node.childern.size()-1;i>=0;i--){
            Node child = node.childern.get(i);
            if(child.childern.size()==0){
                node.childern.remove(child);
            }
        }

        for(Node child: node.childern){
            removeLeaves(child);
        }
    }

    public static void doLinearize(Node node){  //O(n^2)

        for(Node child: node.childern){
            doLinearize(child);
        }

        while (node.childern.size()>1){
            //Here we last leaf from Tree
            //pointing second last child to last child.
            Node lastchild = node.childern.remove(node.childern.size()-1);
            Node secondlastchild = node.childern.get(node.childern.size()-1);
            Node secondlasttail = getTail(secondlastchild);
            secondlasttail.childern.add(lastchild);
        }

    }

    public static Node doLinearize2(Node node){ //O(n)
        if(node.childern.size()==0){ //leaf cannot be linearize so returning Node.
            return node;
        }
        Node lasttail = doLinearize2(node.childern.get(node.childern.size()-1)); // will linearize and return last tail (overall tail).
        while (node.childern.size()>1){
            Node last = node.childern.remove(node.childern.size()-1); //removing and storing last
            Node secondlast = node.childern.get(node.childern.size()-1); //second last...asking tail.
            Node secondlasttail  = doLinearize2(secondlast); //linearize and return second last tail.
            secondlasttail.childern.add(last); //add last to second last tail.
        }
        return lasttail; //Overall Tail of tree.
    }

    public static boolean findElement(Node node,int element){
        if(node.data==element){
            return true;
        }
        for (Node child: node.childern) {
            boolean findinchild = findElement(child, element);
            if (findinchild){
                return true;
            }
        }
        return false;
    }

    public static ArrayList<Integer> findNodeToRootPath(Node node, int element){

        if(node.data==element){
            ArrayList<Integer> list = new ArrayList<>();
            list.add(node.data);
            return list;
        }

        for (Node child: node.childern) {
            ArrayList<Integer> pathtillchild = findNodeToRootPath(child,element);
            if(pathtillchild.size()>0){
                pathtillchild.add(node.data);
                return pathtillchild;
            }
        }

        return new ArrayList<>();
    }

    public static int lowestCommonAncestor(Node node,int e1,int e2){
        /*
        Here we are taking help from findNodeToRootPath method for getting path of two elements e1 and e2
        after getting path we check in both arraylist and compare elements on both lists by reversing loops.
        the node where both the two elements are differ, we come out of the loop and increment loop by 1 to get their common node.
         */
        ArrayList<Integer> p1 = findNodeToRootPath(node,e1);
        ArrayList<Integer> p2 = findNodeToRootPath(node,e2);

        int i = p1.size()-1;
        int j = p2.size()-1;

        while (i>=0 && j>=0 && p1.get(i)==p2.get(j)){
            i--;
            j--;
        }
        i++;
        j++;

        return p1.get(i);
    }

    public static int distanceBetweenNodes(Node node,int e1,int e2){

        ArrayList<Integer> p1 = findNodeToRootPath(node,e1);
        ArrayList<Integer> p2 = findNodeToRootPath(node,e2);

        int i= p1.size()-1;
        int j=p2.size()-1;

        while (i>=0&&j>=0&&p1.get(i)==p2.get(j)){
            i--;
            j--;
        }
        i++;
        j++;

        return i+j;
    }

    private static Node getTail(Node node) {
        while (node.childern.size()==1){
            node = node.childern.get(0);
        }
        return node;
    }



// Can Create Seprate Main Class (We Should)

    public static void main(String[] args){
        int [] arr = {10,20,50,-1,60,-1,-1,30,70,-1,80,110,-1,120,-1,-1,90,-1,-1,40,100,-1,-1,-1};
        Node root = null;
        Stack<Node> stack = new Stack<>();


        for (int i = 0;i < arr.length;i++) {
            if (arr[i] == -1) {
                stack.pop();
            }
            else
            {
                Node n = new Node();
                n.data = arr[i];
                if (!stack.isEmpty()) {
                    stack.peek().childern.add(n);
                } else {
                    root = n;
                }
                stack.push(n);
            }
        }

        display(root);
        System.out.println("Size of Generic Tree : "+ size(root));
        System.out.println("Maximum of Generic Tree : "+maximum(root));
        System.out.println("Height of Generic Tree : "+height(root));
        traversals(root);
        levelOrderTraversal(root);
        levelOrderLineWiseTraversal(root);
        zigZagTraversal(root);
        levelOrderLineWiseTraversal2(root);
        levelOrderLineWiseTraversal3(root);
    }
}
